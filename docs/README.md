## OOP(面向对象)

==最重要的是理解，练习，熟悉面向对象编程的特点==，并能应用于自己的代码中

### 面向对象

#### 简介

在面向对象编程中，所有的一切都是基于对象的概念，这些对象单元包含了如下一些要素：

- Data（State）：数据、状态

- Methods（Behavior）：用来操作数据的方法，即行为

  在函数式编程中，数据和方法是互相独立的			、



#### OOP的好处

- 降低程序复杂度（把一个大程序拆分成不同的小对象）
- 易于维护（在面向过程编程中，程序最后会演变成一大堆方法的各种组织形式）
- 利于代码重用
- 更快速的开发过程



#### oop与pop的优缺点

- 面向过程:

  面向过程就是开发时,分析的是问题的解决步骤,然后调用方法一步一步去解决.不同的问题,不同的解决方案

  **优点:  执行时间短,效率高, 比如: 游戏开发采用C语言(面向过程的开发语言)**

  **缺点: 代码不能复用.**

- 面向对象

  面向对象就是开发时, 分析问题的具体实现对象是"谁", 而不考虑具体的实现过程.

  **优点: 代码可以复用**

  **缺点: 执行时间长,效率低.**



### 类和对象

#### 介绍

类：类是一个**模板**，它描述**一类对象**的行为和状态。具备某些共同特征的实体的集合，它是一种抽象的数据类型，它是**对所具有相同特征实体的抽象**。在面向对象的程序设计语言中，类是对一类“事物”的属性与行为的抽象。  

对象：万物皆对象，它是类的一个实例，对象是一种个性的表示，表示一个独立的个体，**每个对象拥有自己独立的属性，依靠属性来区分不同对象**。

```txt
简单说：

类：定义了对象应具有的特征和行为，类是对象的模板。

对象：拥有多个特征和行为的实体，对象是类的实例。
```



> **static :**
>
> 成员变量（方法）: 实例化成员变量/方法(没有**被static修饰**) 和 类成员变量/方法(被static修饰)
>
> 1. 实例化成员变量/方法(没有被static修饰) : 必须通过对象来调用
> 2. 类成员变量/方法(被static修饰): 可以通过类名直接调用, 也可以通过对象来调用



#### 成员变量和局部变量

区别：(从以下几方面来说)

- 类中定义的位置
- 内存中存储位置
- 初始化值
- 权限符（局部变量只能被 default 和final修饰）
- 生命周期    



#### 构造方法

1. 如果没有提供构造方法, 类中有一个默认的没有参数的构造方法.
2. 如果类里面提供了有参数的构造方法, 那么无参数的构造方法就没有了

**方法重载**

==方法名称必须相同,方法的参数个数,参数类型,参数类型的顺序可以不同.与返回值无关.==

**构造方法重载**

- 没有参数的构造方法: 用来创建对象的
- 带有参数的构造方法: **1. 用来创建对象   2. 可以给成员变量赋值**



### 内存分配

`Java`通过内存来存储和管理数据，并将其划分为两个区域：、

![1658145505799](E:\qianfengStudy\firstStage\资料夹\OOP\assets\1658145505799.png)



- 基本数据类型：存储在栈这个区域
- 引用数据类型：首先计算赋值表达式的右值，也即是对象，将其保存在堆这个区域，并且得到一个内存地址（引用，例如0x10），然后将这个内存地址通过一个变量，也即赋值表达式的左值（例如tb），保存在栈这个区域。tb这个变量通过内存地址引用了保存在内存堆中的一个对象，这就是我们为什么称之为引用类型数据的原因。

> `Java`不同于 `C/C++`，它不需要通过编码释放内存，当我们执行完一个代码块，其中保存在栈区域的变量都会被移除掉。同时，后台还会有一个进程（`Garbage Collection`，简称`GC`，即垃圾回收器），随时监控堆区域，如果堆区域的对象没有被引用，那么它们也会在某个时间点被自动释放掉。



### 封装

##### 概念

封装就是隐藏对象的属性和实现细节，只对外公开一些操作内部属性的方法（接口/函数）

##### 目的（好处）

增强安全性、针对于安全级别高的数据，可以设置成”私有“，可以控制数据为只读（外界无法修改），也可以拦截数据的写操作（进行数据校验和过滤）； 

简化编程，使用者不必了解具体的实现细节，只需要通过外部接口，就可以对类的内部成员进行操作

利于代码的维护 ，如果后期，功能代码需要维护，则直接修改这个类内部代码即可；只要保证接口名称不变，外界不需要做任何代码修改。 

##### Getters & Setters

通过以上手段封装的类，仍然存在以下几个问题需要解决：

- 无法限制用户的`read/write`
- 对用户输入的数据，需要在类的外部单独编写逻辑

为了解决上述问题，我们可以给类的属性配备`Getters & Setters`



### this（super）

通过this来区分成员变量和局部变量. this.成员变量名称

this就表示当前对象, 通俗的来讲, this在那个类里面使用, this就表示当前类对象.

##### this作用:

- 作用一: this操作成员变量
- 作用二: this调用方法
- 作用三: this调用构造方法(了解即可)

##### 细节：

- this和static不能一起使用，this是指对象，而static是和类一起加载的。
- `this`用来指代当前对象，加一对括号即可以调用当前类的构造器方法。
- ==super();和this();都是在构造函数的第一行，不能同时出现。== 



小结：

```txt
> Q1：如何理解类和对象

【下定义】类是关于一系列相似对象的概括描述，描述它们共有的状态、行为，通过这种共性的定义，我们可以重构出许许多多类似的对象。

而对象，即是根据上述类的定义，“克隆”产生的相关实例，这些实例往往在某些属性或行为上是类似但有细节不同的，比如都有姓名，但具体的名字不同。

【组成】类大体包含两种要素，我们统称为成员：

- 成员变量：体现为属性、状态、数据
- 成员方法：体现为函数或方法，或者做某件事情的能力

【关系】类与对象之间的关系：当我们依照类A创建了a1实例的时候，我们可以说 a1 is a member of A

> Q2:如何理解封装和抽象

封装（动词），既可以用于封装类型，也可以用于封装方法。

在封装类型的时候，即是把这个类型的2要素（成员变量和方法）包装到一个单元（class 文件）里面

在封装方法的时候，即是把专注做“某件事情”（执行某一个特定算法）的代码段用方法体包含起来

在封装的时候，要用“抽象”这种思维能力，做到关注主要的（所有实例共有的），忽略次要的（特别的，只有某些特殊实例才具备的）。

抽象还体现在，当我们使用一个类型的实例的时候，在调用其方法时，只需要关注有哪些入参，可以得到什么返回，而无需关注内部的具体实现方式或细节
```



### Object类

Java 中，所有的类都直接或间接的继承自`Object`。因此我们定义的类自然也从这个父类获得了如下方法：

- hashCode：得到一个整数值，它是基于内存地址运算出来的（hashCode是内存地址的一种表现方式）
- equals：用来比较两个对象是否相等。（equals在默认情况下，使用的是Object编写的逻辑，它依然是执行的"=="，也就是地址的比较）

> ```
> 就近原则：
> // 1、自己重写了，用自己的；
> // 2、自己没有，用父亲的，
> // 3、父亲没有，继续往祖辈追溯，找到为止
> ```

- toString：对象的字符串表现形式



### 继承

##### 概念

​	所谓继承本质就是实现代码的复用，防止重复的代码多次书写，当一个类继承一个类的时候，该类中就会获得另一个类型的对象的属性的方法。 它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 

> Java是单继承的， 一个子类只能有一个父类 (除了接口之间的继承是多多继承)

##### 继承的意义

代码重用（最重要）  体现不同抽象层次

##### 方法的重写

`Method Overriding`，当子类不满从父类继承的方法时，可以通过方法重写来改变其具体实现方式。

> 方法重载：同名不同参，即方法签名不一样，仅仅只是方法名相同
>
> 方法重写：同名同参，即方法签名一样

==重写时，子类方法权限一定要大于等于父类方法权限；==

==静态只能覆盖静态。==

> 类型转换：主要分为向上（自动）和向下转型（需要在变量前面加以类型修饰）

##### 继承中的执行顺序

静态代码块、构造代码块，构造方法的**执行顺序**：

父类静态代码块→子类静态代码块→父类构造代码块→父类构造方法→子类构造代码块→子类构造方法

> ```java
> // TODO 面试题：父子类中各个资源的初始化顺序 - 静态优先，然后是父类型优先
> //
> // 1、父亲的静态属性 (1)
> // 2、子类的静态属性 (1)
> // 3、初始化父亲中的属性
> // 4、构造父亲实例
> // 5、初始化子类中的属性
> // 6、构造子类实例
> ```

##### 比较对象

（XX    instanceof    XX	）判断其左边对象是否为其右边类的实例，返回boolean类型的数据。 

> 如何比较对象
>
> - ==用来比较两者的地址(引用)，基本类型直接比较值
> - 我们如果要实现"当这个对象中某些个属性值相等，我们就认为这是两个相同的对象"，可以使用equals
> - 重写Object的equals方法（默认比较的是地址）

##### 继承的好处

提高代码的复用性 为多态提供了前提 

##### 继承的弊端

继承让类之间产生了关系，当父类发生变化时子类也跟着变化，削弱了子类的独立性。 

**注意**：

- 父类的构造方法子类不能继承 。

- 子类可以继承父类的私有成员,但是子类中不能直接访问私有成员。 

- 就近原则，自己有用自己的，否则用父亲的

- 报错的场景：当父亲编写了一个有参数的构造器的时候，就会==编译出现问题==

  JVM在实例话子类型的时候，会默认调用父类型的无参构造器（默认构造器）

  

### 内部类

> 将一个类定义在另一个类里面，里面的那个类就称为内部类。内部类的出现，再次打破了Java单继承的局限性。 	

#### **访问特点**

- 内部类可以直接访问外部类的成员，包括私有成员。

- 外部类要访问内部类的成员，必须要建立内部类的对象。
  **内部类分类及共性**：

  *共性*：

  - 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号。
  - 内部类不能用普通的方式访问。内部类是外部类的一个成员，因此内部类可以自由地访问外部类的成员变量，无论是否是private的。



#### *成员内部类*

在外部类中有成员变量和成员方法，成员内部类就是把整个一个类作为了外部类的成员；
成员内部类是定义在**类中方法外**的类；
创建对象的格式为：**外部类名.内部类名 对象名 = 外部类对象.内部类对象**；
成员内部类之所以可以直接访问外部类的成员，那是因为内部类中都持有一个外部类对象的引用：**外部类名.this**；
成员内部类可以用的修饰符有final，abstract，public，private，protected，static.

#### *静态内部类*

静态内部类就是成员内部类加上静态修饰符static，定义在**类中方法外**。

在外部类中访问静态内部类有两种场景：

- 在外部类中访问静态内部类中非静态成员：***外部类名.内部类名 对象名 = 外部类名.内部对**象*，需要通过创建对象访问；
- 在外部类中访问静态内部类中的静态成员：同样可以使用上面的格式进行访问，也可以直接使用**外部类名.内部类名.成员**。

#### 局部内部类

局部内部类是定义在方法中的类。

- 方法内部类只能在定义该内部类的**方法内**实例化，不可以在此方法外对其实例化。
- 方法内部类对象不能使用该内部类所在方法的非final局部变量。

可以用于方法内部类的修饰符有*final，abstract*；

静态方法中的方法内部类只能访问**外部的静态成员**。

#### *匿名内部类*

匿名内部类是内部类的简化写法，是建立一个带内容的外部类或者接口的子类匿名对象。
前提：
内部类可以继承或实现一个外部类或者接口。
格式：
new 外部类名或者接口名(){重写方法};
通常在方法的形式参数是接口或者抽象类，并且该接口中的方法不超过三个时，可以将匿名内部类作为参数传递。



### final关键字

#### final是什么

final是一个关键字，可以用于修饰类，成员变量，成员方法。

#### 特点

1. 它修饰的类不能被继承。
2. 它修饰的成员变量是一个常量。
3. 它修饰的成员方法是不能被子类重写的。

> final修饰的常量定义一般都有书写规范,被final修饰的常量名称,所有字母都**大写**。

#### 初始化

final修饰成员变量,必须初始化,初始化有两种

- 显示初始化；
- 构造方法初始化。(构造方法的特殊性)
  但是不能两个一起初始化

#### **修饰符** final

- 基本类型：值不能改变
- 引用类型：地址不能改变（但凡是new了，地址一定改变了，如果通过setter进行修改，地址没有改变）
- 修饰类、方法：类不能被继承了，方法不能被重写了
- 但是构造器可以进行第一次赋值



#### final和private的区别

1. final修饰的类可以访问；
   private不可以修饰外部类，但可以修饰内部类（其实把外部类私有化是没有意义的）。
2. final修饰的方法不可以被子类重写；
   private修饰的方法表面上看是可以被子类重写的，其实不可以，子类是看不到父类的私有方法的。
3. final修饰的变量只能在显示初始化或者构造函数初始化的时候赋值一次，以后不允许更改；
   private修饰的变量，也不允许直接被子类或一个包中的其它类访问或修改，但是他可以通过set和get方法对其改值和取值。



### static

**特点**

1. 修饰属性：全局公用（这个类的所有实例共有的），它不依赖于某一个实例而存在，类只要一加载就存在了
2. 修饰方法：静态方法只能引用静态属性（在引用非静态属性的时候，这个this没有指向）
3. 静态代码块：只执行一次，并且时间点在构造器之前，在静态属性初始化之后



### 多态（polymorphic ）

#### 什么是多态（基于继承）

多态就是一个行为在不同条件下，有不同的运行效果。**即允许==一个对象有多种体现形式。==**

就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。

> ==**编译看左边运行看右边**== -----能做什么看左边，具体怎么做看右边

#### 好处和作用

多态的存在提高了程序的**扩展性**和后期**可维护性**。

#### 弊端

父类调用的时候只能调用父类里的方法，不能调用子类的特有方法，因为你并不清楚将来会有什么样的子类继承你。

> 注意：
>
> 一定不能够将父类的对象转换成子类类型！
>
> 父类的引用指向子类对象，该引用可以被提升，也可以被**强制转换**。
>
> **多态自始至终都是子类对象在变化！**



### 抽象类（abstract）

##### 什么是抽象类

当我们不想封装一个具体的类的时候，之所以不想封装出来，是因为他的行为比较抽象，无法编写出具体的逻辑。

##### 意义

抽象类存在的意义，是为了定义一些公共的成员（属性、方法）让子类来继承。起到代码复用的效果。(通过隐藏不必要的细节，来降低复杂度（降低外部调用的复杂度）)

##### 归纳

> **抽象类特点：**
>
> 抽象方法一定在抽象类中；
> 抽象方法和抽象类都必须被abstract关键字修饰；
> 抽象类不可以用new创建对象，因为调用抽象方法没意义；
> 抽象类中的抽象方法要被使用，必须由子类复写其所有的抽象方法后，建立子类对象调用； 如果子类只覆盖了部分的抽象方法，那么该子类还是一个抽象类；
> 抽象类中可以有抽象方法，也可以有非抽象方法，抽象方法用于子类实例化；
> 如果一个类是抽象类，那么，继承它的子类，要么是抽象类，要么重写所有抽象方法。
> 特殊：抽象类中可以不定义抽象方法，这样做仅仅是不让该类建立对象。
>
> **抽象类的成员特点**：
>
> - 成员变量：可以是变量，也可以是常量；
> - 构造方法：有构造方法；
> - 成员方法：可以是抽象方法，也可以是非抽象方法。

##### 注意事项

**抽象类注意事项**：

- *抽象类不能被实例化，为什么还有构造函数*？

只要是class定义的类里面就肯定有构造函数。抽象类中的函数是给子类实例化的。

- *一个类没有抽象方法，为什么定义为抽象类*?

不想被继承，还不想被实例化。

- *抽象关键字abstract不可以和**哪些关键字**共存*？

  - final：如果方法被抽象，就需要被覆盖，而final是不可以被覆盖，所以冲突。
  - private：如果函数被私有了，子类无法直接访问，怎么覆盖呢？
  - static：不需要对象，类名就可以调用抽象方法。而调用抽象方法没有意义。

- > ==*abstract不能用于修饰成员变量*, 不能用于修饰局部变量, 即 没有抽象变量、没有抽象成员变量等说法;abstract也不能用于修 饰构造器,没有抽象构造器,抽象类里定义的构造器只能是普通构 造器。== 

  



### 接口（interface）

> 接口之间是：多继承
>
> 类之间，类与接口之间是：单继承，多实现
>
> 接口在设计之初，是为了能编写出`松耦合`、`易扩展`、`可测试`的应用程序。
>
> 接口编译之后生成的文件也是class 

#### 介绍

接口就像是一个类，但是里面一般只定义方法，而且这个方法没有任何实现细节。换句话说，接口只定义它应该做什么。------有一个例外就是default修饰的方法是可以有方法体的。

- interface，主要用来定义应该做什么（what），例如数据压缩、加密解密、排序、查找
- class，主要用来定义具体怎么做（how）



#### 接口归纳

主要是用来封装一揽子抽象方法的，它侧重在于对行为的一种抽象（动词）

- 必须使用implements关键字
- 实现接口的类，必须要实现其中所有的抽象方法，只要有一个没有实现，这个类本身必须声明为abstract class
- 接口也可以定义属性，但是它默认是public final static    成员方法默认public   abstract
- 接口中不能有具体的方法实现，它只是一种行为的规约（规范和约定）
- 接口中其实可以定义具体方法（默认方法，可以定义多个），前面必须加default修饰
- 接口可以说是抽象类抽象到极致的一种特殊情况



————————————————





#### 抽象类和接口的区别：

*成员变量*

- 抽象类能有变量也可以有常量
- 接口只能有常量

*成员方法*

- 抽象类可以有非抽象的方法,也可以有抽象的方法
- 接口只能有抽象的方法

*构造方法*

-抽象类有构造方法
-接口没有构造方法

*类与抽象类和接口的关系*

- 类与抽象类的关系是继承 extends
- 类与接口的关系是实现 implements

![1658158300577](E:\qianfengStudy\firstStage\资料夹\OOP\assets\1658158300577.png)



#### 面向接口编程的益处

- 灵活切换实现方式
- 是的程序更容易扩展，同时最小化扩展带来的负面影响
- 更容易进行独立的单元测试



#### ***接口解耦四步骤

- 一，新增一个接口，把要提取的方法封装到接口中来
- 二，实现接口中的方法，写一个 实现类（方便以后的扩展，只需要添加扩展实现类就可）
- 三，以接口的方式定义成员变量
- 四，通过构造器从外部传递一个具体的实现者



#### **接口的思想特点**：

1. 接口是*对外暴露*的规则；
2. 接口是程序的*功能扩展*；
3. 接口的出现*降低耦合性*；(实现了模块化开发,定义好规则,每个人实现自己的模块,大大提高了开发效率)
4. 接口可以用来*多实现*；
5. *多个*无关的类可以实现同一个接口；
6. 一个类可以实现*多个*相互直接没有关系的接口；
7. 与继承关系类似，接口与实现类之间存在*多态性*。



### 依赖注入（DI)

> 这个传递依赖的具体实现（实例）给使用者的过程，就称之为依赖注入。

依赖注入有以下3种实现方式：

- 构造器注入
- Setter注入
- 方法注入



### 接口新语法

在 Java 9 中，一个接口中能定义如下几种变量/方法：

- **常量**
- **抽象方法**
- **默认方法**（default）
- **静态方法**
- **私有方法**
- **私有静态方法**

#### 介绍：

- ##### ==定义常量==

  格式：

  **public static final** 数据类型 常量名称 = 数据值；（常量）

  注: 一旦使用final关键字进行修饰，说明**不可改变**。

  注意事项;

  1.接口当中的常量，可以省略public static final ，注意：不写也照样表达这个意思。

  2.接口当中的常量，必须进行赋值：不能不赋值。

  3.接口中常量的名称，使用完全大写的字母，用下划线进行分隔。(推荐这种命名规则）

- ##### ==默认方法==

  **总结：**
  1、接口默认方法、静态方法可以有多个。
  2、默认方法通过实例调用，静态方法通过接口名调用。
  3、**default**默认方法关键字只能用在接口中。
  4、默认方法可以被继承，如果继承了多个接口，多个接口都定义了多个同样的默认方法，实现类需要重写默认方法不然会报错。
  5、**静态方法不能被继承及覆盖**，所以只被具体所在的接口调用。

- ##### ==私有方法==

  问题描述：
  我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。 但是这个共有方法不应该让实现类使用，应该是私有化的。
  ✔解决方案：
  从Java 9开始，接口当中允许定义私有方法。

  1. 普通私有方法，解决多个默认方法之间重复代码问题
     格式：
       private 返回值类型 方法名称(参数列表) {
       方法体
       }
  2. 静态私有方法，解决多个静态方法之间重复代码问题
     格式：
       private static 返回值类型 方法名称(参数列表) {
       方法体
       }





## 不同修饰符修饰的内容

|           | 类   | 成员变量 | 成员方法 | 构造方法 |
| --------- | ---- | -------- | -------- | -------- |
| private   |      | Y        | Y        | Y        |
| 默认      | Y    | Y        | Y        | Y        |
| protected |      | Y        | Y        | Y        |
| public    | Y    | Y        | Y        | Y        |
| abstract  | Y    |          | Y        |          |
| static    |      | Y        | Y        | Y        |
| final     | Y    | Y        | Y        |          |

注意，常见规则如下：

- 以后，所有的类都用public修饰。并且，在一个java文件中，只写一个类。
- 以后，所有的成员变量用private修饰。
- 以后，所有的成员方法用public修饰。
  如果是抽象类或者接口：public abstract + …
- 以后，所有的构造方法用public修饰。
  如果类是工具类或者单例类：构造用private修饰

## 四种权限修饰符

|           | 本类 | 同包（无关类或子类） | 不同包（子类） | 不同包（无关类） |
| --------- | ---- | -------------------- | -------------- | ---------------- |
| private   | Y    |                      |                |                  |
| 默认      | Y    | Y                    |                |                  |
| protected | Y    | Y                    | Y              |                  |
| public    | Y    | Y                    | Y              | Y                |

推荐：

- 成员变量 private
- 构造方法 public
- 成员方法 public



```java
// 设计程序的时候，一定要站在调用方的角度考虑问题
// 要精确的进行小数运算，包括多有效位数的，需要使用    BigDecimal
// CTRL + SHIFT + U 批量转换大小写
// static 修饰的内容，是不依赖于这个类的任何实例的，当这个类一旦在运行期间加载进来，它就已经存在，有且只有一份，大家共享的
// static修饰的方法只能访问static修饰的变量
// 对于引用类型，只要它自己的地址不发生改变，也可以修饰为final的（地址里面的内容可以改变）
// 虽然arr被修饰为final，表示不能修改地址，但是构造器特殊一点，有特权进行修改（final关键字特殊的一点）
// 因为它就是干"初始化"这个活儿的
// 用短路思路来编写：让程序尽早返回结果 / 让不合格的元素尽早退出该段逻辑
```

